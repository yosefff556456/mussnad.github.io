<!DOCTYPE html>
<html>
<head>
    <title>خريطة الأسلاف التفاعلية</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
    <style>
        #map {
            height: 600px;
            width: 100%;
        }
        .ancestor-label {
            font-weight: bold;
            text-align: center;
            color: black;
            text-shadow: 1px 1px 2px white;
        }
    </style>
</head>
<body>

<h2>خريطة الأسلاف التفاعلية</h2>
<div id="map"></div>

<script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js"></script>

<script>
const csvUrl1 = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vRuMXx0shOoaXKp9nxINFg5TI7C30bKfIXEkYl_dBsDcmgeXCYzgzZiMrkLnKwkqA/pub?output=csv';
const csvUrl2 = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vQ_OnJg9i2DLOh8DSYejqL8fsDnSwa2-YTD63Nkq7JccI7VApcTsm7WiJe6eVRUOQ/pub?output=csv';

const map = L.map('map').setView([16.6161, 43.0556], 6);

L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: '&copy; مساهمة OpenStreetMap'
}).addTo(map);

function calculateWeightedCoordinates(samples) {
    let totalLat = 0;
    let totalLon = 0;
    let totalWeight = 0;
    samples.forEach(sample => {
        const weight = sample.weight;
        totalLat += parseFloat(sample.lat) * weight;
        totalLon += parseFloat(sample.lon) * weight;
        totalWeight += weight;
    });
    return {
        lat: totalLat / totalWeight,
        lon: totalLon / totalWeight
    };
}

function buildAncestorsTree(data) {
    const ancestorsTree = {};

    data.forEach(item => {
        const ancestorsStr = item['Ancestors'];
        let lat = item['Latitude'] ? item['Latitude'].replace(',', '.').replace('٫', '.') : '';
        let lon = item['Longitude'] ? item['Longitude'].replace(',', '.').replace('٫', '.') : '';

        if (!lat || !lon) {
            return;
        }

        const ancestorList = ancestorsStr.split('>').map(ancestor => ancestor.trim());

        if (ancestorList.some(ancestor => ancestor.includes('*'))) {
            return;
        }

        ancestorList.forEach((ancestor, index) => {
            const ancestorKey = ancestorList.slice(0, index + 1).join('>');
            if (!ancestorsTree[ancestorKey]) {
                ancestorsTree[ancestorKey] = {
                    name: ancestor,
                    parent: index > 0 ? ancestorList.slice(0, index).join('>') : null,
                    samples: [],
                    children: [],
                    level: index
                };
            }
            if (index === ancestorList.length - 1) {
                ancestorsTree[ancestorKey].samples.push({ lat: lat, lon: lon, weight: item.weight });
            }
        });
    });

    Object.values(ancestorsTree).forEach(node => {
        if (node.parent && ancestorsTree[node.parent]) {
            ancestorsTree[node.parent].children.push(node);
        }
    });

    return Object.values(ancestorsTree).filter(node => !node.parent);
}

function addAncestorsToMap(nodes, parentCoords = null) {
    nodes.forEach(node => {
        let avgCoords = null;
        if (node.samples.length > 0) {
            avgCoords = calculateWeightedCoordinates(node.samples);
        } else if (parentCoords) {
            avgCoords = parentCoords;
        } else {
            return;
        }

        if (avgCoords && avgCoords.lat && avgCoords.lon) {
            const fontSize = 16 + (5 * (5 - node.level));

            const myIcon = L.divIcon({
                className: 'ancestor-label',
                html: `<div style="font-size: ${fontSize}px;">${node.name}</div>`
            });

            L.marker([avgCoords.lat, avgCoords.lon], { icon: myIcon }).addTo(map);

            if (parentCoords && (avgCoords.lat !== parentCoords.lat || avgCoords.lon !== parentCoords.lon)) {
                L.polyline([
                    [parentCoords.lat, parentCoords.lon],
                    [avgCoords.lat, avgCoords.lon]
                ], { color: 'blue' }).addTo(map);
            }

            addAncestorsToMap(node.children, avgCoords);
        }
    });
}

function loadCSV(url, weight) {
    return fetch(url)
        .then(response => response.text())
        .then(csvText => {
            const parsed = Papa.parse(csvText, {
                header: true,
                delimiter: ',',
                skipEmptyLines: true,
                dynamicTyping: true
            });
            parsed.data.forEach(row => {
                row.weight = weight;
            });
            return parsed.data;
        });
}

Promise.all([
    loadCSV(csvUrl1, 1),
    loadCSV(csvUrl2, 2)
])
.then(([data1, data2]) => {
    const combinedData = data1.concat(data2);
    const roots = buildAncestorsTree(combinedData);
    addAncestorsToMap(roots);
})
.catch(error => {
    console.error('خطأ في تحميل ملفات CSV:', error);
});
</script>
</body>
</html>
